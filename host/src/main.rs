// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use anyhow::Context;
use core::{EntryFunction, InMemoryStorage, Transaction, TransactionPayload, SYS_ACCOUNT_LOOKUP};
use methods::{GUEST_MOVE2RISC0_ELF, GUEST_MOVE2RISC0_ID};
use move_compiler::shared::{NumberFormat, NumericalAddress};
use move_compiler::{Compiler, Flags};
use move_core_types::account_address::AccountAddress;
use move_core_types::identifier::Identifier;
use move_core_types::language_storage::ModuleId;
use risc0_smt::{Key, Smt, Value};
use risc0_zkvm::sha::{self, Sha256};
use risc0_zkvm::{default_prover, ExecutorEnv, Receipt};
use std::collections::{BTreeSet, HashMap};
use std::str::FromStr;

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // TODO: make transactions an input (e.g. from file)
    let module_id_add = ModuleId::new(AccountAddress::ZERO, Identifier::from_str("add").unwrap());
    let module_id_fib = ModuleId::new(AccountAddress::ZERO, Identifier::from_str("fib").unwrap());

    let add_tx = Transaction {
        payload: TransactionPayload::EntryFunction(EntryFunction {
            module: module_id_add.clone(),
            function: Identifier::from_str("main").unwrap(),
            ty_args: Vec::new(),
            args: Vec::new(),
        }),
    };

    let fib_tx = Transaction {
        payload: TransactionPayload::EntryFunction(EntryFunction {
            module: module_id_fib.clone(),
            function: Identifier::from_str("main").unwrap(),
            ty_args: Vec::new(),
            args: Vec::new(),
        }),
    };

    // TODO: read storage from disk
    let mut storage = InMemoryStorage::new();
    storage.publish_or_overwrite_module(module_id_add, move_compile("arithmetic").unwrap());
    storage.publish_or_overwrite_module(module_id_fib, move_compile("repeat").unwrap());

    let mut hash_reverse_map = HashMap::new();

    // TODO: read SMT from disk
    // TODO: populate in-memory SMT only with values needed for transactions
    let mut smt = Smt::new();
    for (k, v) in &storage.accounts {
        let key = sha::Impl::hash_bytes(k.as_ref());
        let account_bytes = v.to_bytes().unwrap();
        let account_hash = sha::Impl::hash_bytes(&account_bytes);
        let value = Value(account_hash.as_words().try_into().unwrap());
        hash_reverse_map.insert(account_hash.as_bytes().to_vec(), account_bytes);
        smt.insert::<sha::Impl>(Key(key.as_words().try_into().unwrap()), value);
    }

    // TODO: run in parallel?
    let add_rx = prove_tx(&add_tx, &smt, &hash_reverse_map);
    let fib_rx = prove_tx(&fib_tx, &smt, &hash_reverse_map);

    // TODO: journal only contains `env::commit` data from guest. How to access `env::write`?

    // Receipt journal is returned value from executing the entry function.
    let output: Vec<u8> = add_rx.journal.bytes;
    println!("Add Output: {output:?}");

    let output: Vec<u8> = fib_rx.journal.bytes;
    println!("Fib Output: {output:?}");

    // TODO: run another zkVM instance to make a single proof from both tx proofs
}

fn prove_tx(
    tx: &Transaction,
    smt: &Smt,
    hash_reverse_lookup: &HashMap<Vec<u8>, Vec<u8>>,
) -> Receipt {
    let env = ExecutorEnv::builder()
        .write(tx) // send transaction as guest input
        .unwrap()
        .write(smt) // send storage as guest input
        .unwrap()
        .io_callback(SYS_ACCOUNT_LOOKUP, |hash| {
            hash_reverse_lookup
                .get(hash.as_ref())
                .ok_or_else(|| anyhow::Error::msg("value not found"))
                .map(|xs| xs.clone().into())
        })
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove(env, GUEST_MOVE2RISC0_ELF).unwrap();

    // The receipt is verified at the end of proving.
    receipt.verify(GUEST_MOVE2RISC0_ID).unwrap();

    receipt
}

fn move_compile(package_name: &str) -> anyhow::Result<Vec<u8>> {
    let known_attributes = BTreeSet::new();
    let named_address_mapping = [(
        package_name,
        NumericalAddress::new([0; 32], NumberFormat::Hex),
    )]
    .into_iter()
    .collect();
    let compiler = Compiler::from_files(
        vec![format!("move_sources/{package_name}.move")],
        Vec::new(),
        named_address_mapping,
        Flags::empty(),
        &known_attributes,
    );
    let (_, result) = compiler
        .build()
        .context(format!("Failed to compile {package_name}.move"))?;
    let compiled_unit = result.unwrap().0.pop().unwrap().into_compiled_unit();
    let bytes = compiled_unit.serialize(None);
    Ok(bytes)
}
