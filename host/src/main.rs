// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use anyhow::Context;
use core::InMemoryStorage;
use methods::{GUEST_MOVE2RISC0_ELF, GUEST_MOVE2RISC0_ID};
use move_compiler::shared::{NumberFormat, NumericalAddress};
use move_compiler::{Compiler, Flags};
use move_core_types::account_address::AccountAddress;
use move_core_types::identifier::Identifier;
use move_core_types::language_storage::ModuleId;
use move_core_types::value::MoveTypeLayout;
use risc0_zkvm::{default_prover, ExecutorEnv};
use std::collections::BTreeSet;
use std::str::FromStr;

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    // Insert the smart contract modules into storage backend
    let mut storage = InMemoryStorage::new();
    let module_id_add = ModuleId::new(AccountAddress::ZERO, Identifier::from_str("add").unwrap());
    let module_id_fib = ModuleId::new(AccountAddress::ZERO, Identifier::from_str("fib").unwrap());
    storage.publish_or_overwrite_module(module_id_add.clone(), move_compile("arithmetic").unwrap());
    storage.publish_or_overwrite_module(module_id_fib.clone(), move_compile("repeat").unwrap());

    let env = ExecutorEnv::builder()
        .write(&storage) // send storage as guest input
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove(env, GUEST_MOVE2RISC0_ELF).unwrap();

    // Receipt journal is returned value from executing the entry function.
    let output: Vec<(Vec<u8>, MoveTypeLayout)> = receipt.journal.decode().unwrap();
    println!("Output: {output:?}");

    // The receipt is verified at the end of proving.
    receipt.verify(GUEST_MOVE2RISC0_ID).unwrap();
}

fn move_compile(package_name: &str) -> anyhow::Result<Vec<u8>> {
    let known_attributes = BTreeSet::new();
    let named_address_mapping = [(
        package_name,
        NumericalAddress::new([0; 32], NumberFormat::Hex),
    )]
    .into_iter()
    .collect();
    let compiler = Compiler::from_files(
        vec![format!("move_sources/{package_name}.move")],
        Vec::new(),
        named_address_mapping,
        Flags::empty(),
        &known_attributes,
    );
    let (_, result) = compiler
        .build()
        .context(format!("Failed to compile {package_name}.move"))?;
    let compiled_unit = result.unwrap().0.pop().unwrap().into_compiled_unit();
    let bytes = compiled_unit.serialize(None);
    Ok(bytes)
}
