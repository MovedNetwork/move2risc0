// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use anyhow::Context;
use methods::{GUEST_MOVE2RISC0_ELF, GUEST_MOVE2RISC0_ID};
use move_compiler::{
    shared::{NumberFormat, NumericalAddress},
    Compiler, Flags,
};
use move_core_types::value::MoveTypeLayout;
use risc0_zkvm::{default_prover, ExecutorEnv};
use std::collections::BTreeSet;

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let bytes: Vec<u8> = move_compile("arithmetic").unwrap();

    let env = ExecutorEnv::builder()
        .write(&bytes) // add guest input
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Produce a receipt by proving the specified ELF binary.
    let receipt = prover.prove(env, GUEST_MOVE2RISC0_ELF).unwrap();

    // Receipt journal is returned value from executing the entry function.
    let output: Vec<(Vec<u8>, MoveTypeLayout)> = receipt.journal.decode().unwrap();
    println!("OUTPUT: {output:?}");

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    receipt.verify(GUEST_MOVE2RISC0_ID).unwrap();
}

fn move_compile(package_name: &str) -> anyhow::Result<Vec<u8>> {
    let known_attributes = BTreeSet::new();
    let named_address_mapping = [(
        package_name,
        NumericalAddress::new([0; 32], NumberFormat::Hex),
    )]
    .into_iter()
    .collect();
    let compiler = Compiler::from_files(
        vec![format!("move_sources/{package_name}.move")],
        Vec::new(),
        named_address_mapping,
        Flags::empty(),
        &known_attributes,
    );
    let (_, result) = compiler
        .build()
        .context(format!("Failed to compile {package_name}.move"))?;
    let compiled_unit = result.unwrap().0.pop().unwrap().into_compiled_unit();
    let bytes = compiled_unit.serialize(None);
    Ok(bytes)
}
